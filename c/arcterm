#if	!defined(lint) && !defined(DOS)
static char rcsid[] = "$Id: tcap.c,v 1.00 29 Dec 1996 15:18.48 Fletcher $";
#endif
/*
 * Program:	Display routines
 *
 * Quickly thrown together by Justin Fletcher <justin.fletcher@ntlworld.com>
 * I've also added a special flag to ensure that we use ANSI sequences -
 * this is used when running under telnetd to output the correct way
 * and it doesn't half look good :-)
 *
 */
/*	tcap:	Unix V5, V7 and BS4.2 Termcap video driver
		for MicroEMACS
*/

#define	termdef	1			/* don't define "term" external */

#include	<stdio.h>
#include        <signal.h>
#include	"osdep.h"
#include        "pico.h"
#include	"estruct.h"
#include        "edef.h"


#if TERMCAP
#ifndef ANSI_DRIVER
#include "swis.h"
#include        "stdlib.h"
#define	MARGIN	8
#define	SCRSIZ	64
#define	MROW	2
#define BEL     0x07
#define ESC     0x1B

extern int      ttopen();
extern int      ttgetc();
extern int      ttputc();
extern int      ttflush();
extern int      ttclose();

static int      tcapmove();
static int      tcapeeol();
static int      tcapeeop();
static int      tcapbeep();
static int	tcaprev();
static int      tcapopen();
static int      tcapclose();
static void     setup_dflt_pico_esc_seq();

extern int      tput();
extern char     *tgoto();

#if 0
#define TCAPSLEN 315
char tcapbuf[TCAPSLEN];
char *UP, PC, *CM, *CE, *CL, *SO, *SE;
/*
 * PICO extentions
 */
char	*DL,			/* delete line */
	*AL,			/* insert line */
	*CS,			/* define a scrolling region, vt100 */
	*IC,			/* insert character, preferable to : */
	*IM,			/* set insert mode and, */
	*EI,			/* end insert mode */
	*DC,			/* delete character */
	*DM,			/* set delete mode and, */
	*ED,			/* end delete mode */
	*SF,			/* scroll text up */
	*SR,			/* scroll text down */
	*TI,			/* string to start termcap */
        *TE;			/* string to end termcap */
#endif

TERM term = {
        NROW-1,
        NCOL,
	MARGIN,
	SCRSIZ,
	MROW,
        tcapopen,
        tcapclose,
        ttgetc,
        ttputc,
        ttflush,
        tcapmove,
        tcapeeol,
        tcapeeop,
        tcapbeep,
        tcaprev
};

/*
 * Add default keypad sequences to the trie.
 */
static void
setup_dflt_pico_esc_seq()
{
    /*
     * this is sort of a hack, but it allows us to use
     * the function keys on pc's running telnet
     */

    /*
     * UW-NDC/UCS vt10[02] application mode.
     */
    kpinsert(&pico_kbesc, "\033OP", F1);
    kpinsert(&pico_kbesc, "\033OQ", F2);
    kpinsert(&pico_kbesc, "\033OR", F3);
    kpinsert(&pico_kbesc, "\033OS", F4);
    kpinsert(&pico_kbesc, "\033Op", F5);
    kpinsert(&pico_kbesc, "\033Oq", F6);
    kpinsert(&pico_kbesc, "\033Or", F7);
    kpinsert(&pico_kbesc, "\033Os", F8);
    kpinsert(&pico_kbesc, "\033Ot", F9);
    kpinsert(&pico_kbesc, "\033Ou", F10);
    kpinsert(&pico_kbesc, "\033Ov", F11);
    kpinsert(&pico_kbesc, "\033Ow", F12);

    /*
     * DC vt100, ANSI and cursor key mode.
     */
    kpinsert(&pico_kbesc, "\033OA", K_PAD_UP);
    kpinsert(&pico_kbesc, "\033OB", K_PAD_DOWN);
    kpinsert(&pico_kbesc, "\033OC", K_PAD_RIGHT);
    kpinsert(&pico_kbesc, "\033OD", K_PAD_LEFT);

    /*
     * special keypad functions
     */
    kpinsert(&pico_kbesc, "\033[4J", K_PAD_PREVPAGE);
    kpinsert(&pico_kbesc, "\033[3J", K_PAD_NEXTPAGE);
    kpinsert(&pico_kbesc, "\033[2J", K_PAD_HOME);
    kpinsert(&pico_kbesc, "\033[N",  K_PAD_END);

    /*
     * ANSI mode.
     */
    kpinsert(&pico_kbesc, "\033[=a", F1);
    kpinsert(&pico_kbesc, "\033[=b", F2);
    kpinsert(&pico_kbesc, "\033[=c", F3);
    kpinsert(&pico_kbesc, "\033[=d", F4);
    kpinsert(&pico_kbesc, "\033[=e", F5);
    kpinsert(&pico_kbesc, "\033[=f", F6);
    kpinsert(&pico_kbesc, "\033[=g", F7);
    kpinsert(&pico_kbesc, "\033[=h", F8);
    kpinsert(&pico_kbesc, "\033[=i", F9);
    kpinsert(&pico_kbesc, "\033[=j", F10);
    kpinsert(&pico_kbesc, "\033[=k", F11);
    kpinsert(&pico_kbesc, "\033[=l", F12);

    /*
     * DEC vt100, ANSI, cursor key mode reset.
     */
    kpinsert(&pico_kbesc, "\033[A", K_PAD_UP);
    kpinsert(&pico_kbesc, "\033[B", K_PAD_DOWN);
    kpinsert(&pico_kbesc, "\033[C", K_PAD_RIGHT);
    kpinsert(&pico_kbesc, "\033[D", K_PAD_LEFT);

    /*
     * DEC vt52 mode.
     */
    kpinsert(&pico_kbesc, "\033A", K_PAD_UP);
    kpinsert(&pico_kbesc, "\033B", K_PAD_DOWN);
    kpinsert(&pico_kbesc, "\033C", K_PAD_RIGHT);
    kpinsert(&pico_kbesc, "\033D", K_PAD_LEFT);

    /*
     * DEC vt52 application keys, and some Zenith 19.
     */
    kpinsert(&pico_kbesc, "\033?r", K_PAD_DOWN);
    kpinsert(&pico_kbesc, "\033?t", K_PAD_LEFT);
    kpinsert(&pico_kbesc, "\033?v", K_PAD_RIGHT);
    kpinsert(&pico_kbesc, "\033?x", K_PAD_UP);

    /*
     * Sun Console sequences.
     */
    kpinsert(&pico_kbesc, "\033[1",   K_SWALLOW_TIL_Z);
    kpinsert(&pico_kbesc, "\033[215", K_SWALLOW_UP);
    kpinsert(&pico_kbesc, "\033[217", K_SWALLOW_LEFT);
    kpinsert(&pico_kbesc, "\033[219", K_SWALLOW_RIGHT);
    kpinsert(&pico_kbesc, "\033[221", K_SWALLOW_DOWN);

    /*
     * Kermit App Prog Cmd, gobble until ESC \ (kermit should intercept this)
     */
    kpinsert(&pico_kbesc, "\033_", K_KERMIT);

    /*
     * Fake a control character.
     */
    kpinsert(&pico_kbesc, "\033\033", K_DOUBLE_ESC);
}


static int
tcapopen()
{
    char   *getenv();
    int     row, col;
    char   *er;
    char   *ec;
    int     cc,rr;

    int sregs[11];

    /*
     * determine the terminal's communication speed and decide
     * if we need to do optimization ...
     */
    optimize = 0;/*ttisslow();*/

    if (taskwindow())
    {
      row=-1; col=-1;
      revexist=FALSE;
    }
    else
    {
      _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),-1,2,&row);/* # of rows */
      _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),-1,1,&col);/* # of cols */

      revexist=TRUE;
    }
    /* Now check if there is an override on these */
    er = getenv("Pico$Lines");
    if (!er) er = getenv("Lines");
    if(er && (rr = atoi(er)) > 0)
      row = rr-1;
    ec = getenv("Pico$Columns");
    if (!ec) ec = getenv("Columns");
    if(ec && (cc = atoi(ec)) > 0)
      col = cc;

    ttgetwinsz(&row, &col);
    term.t_nrow = (short) row;
    term.t_ncol = (short) col;

    eolexist = TRUE;	/* will we be able to use clear to EOL? */
    delchar = FALSE;
    inschar = FALSE;
    scrollexist = FALSE;

    setup_dflt_pico_esc_seq();

    /*
     * Initialize UW-modified NCSA telnet to use it's functionkeys
     */
    if(gmode&MDFKEY && Pmaster == NULL)
      puts("\033[99h");

    ttopen();
}


static int
tcapclose()
{
    if(!Pmaster){
	if(gmode&MDFKEY)
	  puts("\033[99l");		/* reset UW-NCSA telnet keys */
    }

    kbdestroy(pico_kbesc);		/* clean up key board sequence trie */
    tcapeeop(); /* clear the screen */
    pico_kbesc = NULL;
    ttclose();
}


/*
 * o_scrolldown - open a line at the given row position.
 *                use either region scrolling or deleteline/insertline
 *                to open a new line.
 */
o_scrolldown(row, n)
register int row;
register int n;
{
  _swix(OS_Write0,_IN(0),"o_scrolldown should not get called\n");
}


/*
 * o_scrollup - open a line at the given row position.
 *              use either region scrolling or deleteline/insertline
 *              to open a new line.
 */
o_scrollup(row, n)
register int row;
register int n;
{
    _swix(OS_Write0,_IN(0),"o_scrollup should not get called\n");
}


/*
 * o_insert - use termcap info to optimized character insert
 *            returns: true if it optimized output, false otherwise
 */
o_insert(c)
char c;
{
    return(0);				/* can't do it. */
}


/*
 * o_delete - use termcap info to optimized character insert
 *            returns true if it optimized output, false otherwise
 */
o_delete()
{
    return(0);				/* no dice. */
}


static int
tcapmove(row, col)
register int row, col;
{
  if (gmode & MDUSEANSI)
  {
    _swix(OS_WriteC,_IN(0),27);
    _swix(OS_WriteC,_IN(0),'[');
    ansiparm(row+1);
    _swix(OS_WriteC,_IN(0),';');
    ansiparm(col+1);
    _swix(OS_WriteC,_IN(0),'H');
  }
  else
  {
    _swix(OS_WriteC,_IN(0),31);
    _swix(OS_WriteC,_IN(0),col);
    _swix(OS_WriteC,_IN(0),row);
  }
}

ansiparm(n)
register int    n;
{
        register int    q;

        q = n/10;
        if (q != 0)
                ansiparm(q);
        _swix(OS_WriteC,_IN(0),((n%10) + '0'));
}

static int
tcapeeol(int fromx)
{
  if (gmode & MDUSEANSI)
  {
    _swix(OS_WriteC,_IN(0),27);
    _swix(OS_WriteC,_IN(0),'[');
    _swix(OS_WriteC,_IN(0),'K');
  }
  else
  {
    if (taskwindow())
    {
      /* TaskWindows (at least Zap ones) don't support the 'delete to end of
         line' */
      int i;
      for (i=term.t_ncol; i>fromx; i--)
      {
        _swix(OS_WriteC,_IN(0),' ');
      }
      for (i=term.t_ncol; i>fromx; i--)
      {
        _swix(OS_WriteC,_IN(0),8);
      }
    }
    else
    {
      _swix(OS_WriteC,_IN(0),23);
      _swix(OS_WriteC,_IN(0),8);
      _swix(OS_WriteC,_IN(0),5);
      _swix(OS_WriteC,_IN(0),6);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
      _swix(OS_WriteC,_IN(0),0);
    }
  }
}


static int
tcapeeop()
{
  if (gmode & MDUSEANSI)
  {
    _swix(OS_WriteC,_IN(0),27);
    _swix(OS_WriteC,_IN(0),'[');
    _swix(OS_WriteC,_IN(0),'J');
  }
  else
  {
    _swix(OS_WriteC,_IN(0),12);
  }
}


static int
tcaprev(state)		/* change reverse video status */
int state;	        /* FALSE = normal video, TRUE = reverse video */
{
  static int cstate = FALSE;

  if(state == cstate)		/* no op if already set! */
    return(0);

  cstate = state;
  if (gmode & MDUSEANSI)
  {
    _swix(OS_WriteC,_IN(0),27);
    _swix(OS_WriteC,_IN(0),'[');
    _swix(OS_WriteC,_IN(0),(state ? '7': '0'));
    _swix(OS_WriteC,_IN(0),'m');
  }
  else
  {
    _swix(OS_WriteC,_IN(0),23);
    _swix(OS_WriteC,_IN(0),17);
    _swix(OS_WriteC,_IN(0),5);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
    _swix(OS_WriteC,_IN(0),0);
  }
}


static int
tcapbeep()
{
  _swix(OS_WriteC,_IN(0),7);
}

#endif /* TERMCAP */
#endif

***************
*** 627,631 ****
  extern char    *tparm();
  #endif
- static void     putpad PROTO((char *));
  static void	tinitcolor PROTO((void));
  static int	tfgcolor PROTO((int));
--- 633,636 ----
  extern char    *tparm();
  #endif
  static void	tinitcolor PROTO((void));
  static int	tfgcolor PROTO((int));
***************
*** 175,180 ****
   *          tty modes, but set signal handlers.
   */
! ttopen()
  {
      if(Pmaster == NULL){
  	Raw(1);
--- 187,206 ----
   *          tty modes, but set signal handlers.
   */
! int ttopen(void)
  {
+ #ifdef __riscos
+   int ret[3];
+ 
+   if(!Pmaster || (gmode ^ MDEXTFB))
+     picosigs();
+   _swix(OS_Byte,_INR(0,2)|_OUT(1),4,2,0,&tt_oldcursorstate);
+   tt_oldcursorstate=ret[1];
+   /* Change function key definitions */
+   _swix(OS_Byte,_INR(0,2)|_OUT(1),225,0x80,0,&tt_oldfunc8state);
+   _swix(OS_Byte,_INR(0,2)|_OUT(1),226,0x90,0,&tt_oldfunc9state);
+   _swix(OS_Byte,_INR(0,2)|_OUT(1),221,0xC0,0,&tt_oldfuncCstate);
+ 
+   return(1);
+ #else
      if(Pmaster == NULL){
  	Raw(1);
***************
*** 171,175 ****
      if(!Pmaster || (gmode ^ MDEXTFB))
        picosigs();
! 
      return(1);
  }
--- 197,201 ----
      if(!Pmaster || (gmode ^ MDEXTFB))
        picosigs();
! #endif
      return(1);
  }
***************
*** 181,185 ****
   */
  void
! ttresize ()
  {
      int row = -1, col = -1;
--- 207,211 ----
   */
  void
! ttresize (void)
  {
      int row = -1, col = -1;
***************
*** 197,201 ****
  picosigs()
  {
      signal(SIGHUP,  do_hup_signal);	/* deal with SIGHUP */
      signal(SIGTERM, do_hup_signal);	/* deal with SIGTERM */
  #ifdef	SIGTSTP
--- 223,231 ----
  picosigs()
  {
+ #ifndef __riscos
      signal(SIGHUP,  do_hup_signal);	/* deal with SIGHUP */
+ #else
+     signal(SIGINT, SIG_IGN);		/* Ignore Escape */
+ #endif
      signal(SIGTERM, do_hup_signal);	/* deal with SIGTERM */
  #ifdef	SIGTSTP
***************
*** 214,219 ****
   *           rewire things as needed.
   */
! ttclose()
  {
      if(Pmaster){
  	signal(SIGHUP, SIG_DFL);
--- 244,260 ----
   *           rewire things as needed.
   */
! int ttclose(void)
  {
+ #ifdef __riscos
+     if(Pmaster){
+ 	signal(SIGINT, SIG_DFL);
+     }
+     _swix(OS_Byte,_INR(0,2),4,tt_oldcursorstate,0);
+     _swix(OS_Byte,_INR(0,2),225,tt_oldfunc8state,0);
+     _swix(OS_Byte,_INR(0,2),226,tt_oldfunc9state,0);
+     _swix(OS_Byte,_INR(0,2),221,tt_oldfuncCstate,0);
+ 
+ #else
+ 
      if(Pmaster){
  	signal(SIGHUP, SIG_DFL);
***************
*** 222,225 ****
      int *row, *col;
  {
      extern int _tlines, _tcolumns;
  
--- 277,296 ----
      int *row, *col;
  {
+ #ifdef __riscos
+   if (taskwindow())
+   {
+     if(*row < 0)
+       *row = 24 - 1;
+     if(*col <= 0)
+       *col = 72;
+   }
+   else
+   {
+     if(*row < 0)
+       *row = NROW - 1;
+     if(*col <= 0)
+       *col = NCOL;
+   }
+ #else
      extern int _tlines, _tcolumns;
  
***************
*** 246,249 ****
      if(*col > NLINE-1)
        *col = NLINE-1;
  }
  
--- 317,321 ----
      if(*col > NLINE-1)
        *col = NLINE-1;
+ #endif
  }
  
***************
*** 252,258 ****
   * ttputc - Write a character to the display. 
   */
! ttputc(c)
  {
      return(putc(c, stdout));
  }
  
--- 324,337 ----
   * ttputc - Write a character to the display.
   */
! int ttputc(c)
! int c;
  {
+ #ifdef __riscos
+   if (_swix(OS_WriteC,_IN(0),c))
+     return EOF;
+   return c;
+ #else
    return(putc(c, stdout));
+ #endif
  }
  
***************
*** 263,269 ****
   *           at a time terminal I/O is done.
   */
  ttflush()
  {
      return(fflush(stdout));
  }
  
--- 342,351 ----
   *           at a time terminal I/O is done.
   */
+ int
  ttflush()
  {
+ #ifndef __riscos
      return(fflush(stdout));
+ #endif
  }
  
***************
*** 326,331 ****
  {
      int		  res;
!     unsigned char c;
  
      while((res = read(STDIN_FD, &c, 1)) <= 0)
        if(!(res < 0 && errno == EINTR))
--- 408,420 ----
  {
      int		  res;
!     int c;
  
+ #ifdef __riscos
+     c = read_one_char();
+     if (c==BAIL_OUT)
+       (*bail_handler)();
+     else
+       return(recorder ? (*recorder)((int)c) : (int)c);
+ #else
      while((res = read(STDIN_FD, &c, 1)) <= 0)
        if(!(res < 0 && errno == EINTR))
***************
*** 333,336 ****
  
      return(recorder ? (*recorder)((int)c) : (int)c);
  }
  
--- 422,426 ----
  
      return(recorder ? (*recorder)((int)c) : (int)c);
+ #endif
  }
  
***************
*** 338,343 ****
  bail()
  {
      sleep(30);				/* see if os receives SIGHUP */
      kill(getpid(), SIGHUP);			/* eof or bad error */
  }
  
--- 428,438 ----
  bail()
  {
+ #ifdef __riscos
+     printf("Bailing!\n");
+     abort();
+ #else
      sleep(30);				/* see if os receives SIGHUP */
      kill(getpid(), SIGHUP);			/* eof or bad error */
+ #endif
  }
  
***************
*** 350,356 ****
  typahead()
  {
      int x;	/* holds # of pending chars */
  
      return((ioctl(0,FIONREAD,&x) < 0) ? 0 : x);
  }
  #endif
--- 445,455 ----
  typahead()
  {
+ #ifdef __riscos
+     return 0;
+ #else
      int x;	/* holds # of pending chars */
  
      return((ioctl(0,FIONREAD,&x) < 0) ? 0 : x);
+ #endif
  }
  #endif
***************
*** 361,365 ****
   *		 is available...
   */
! ReadyForKey(timeout)
      int timeout;
  {
--- 460,464 ----
   *		 is available...
   */
! int ReadyForKey(timeout)
      int timeout;
  {
***************
*** 377,382 ****
        case PANIC_NOW:
  	emlwrite("\007Problem reading from keyboard!", NULL);
  	kill(getpid(), SIGHUP);	/* Bomb out (saving our work)! */
  	/* no return */
      }
  
--- 476,486 ----
        case PANIC_NOW:
  	emlwrite("\007Problem reading from keyboard!", NULL);
+ #ifndef __riscos
  	kill(getpid(), SIGHUP);	/* Bomb out (saving our work)! */
  	/* no return */
+ #else
+         printf("input_ready returned a fault!!\n");
+         raise(SIGINT);
+ #endif
      }
  
***************
*** 392,396 ****
   * timeout value exceeded.
   */
! GetKey()
  {
      int    ch, status, cc;
--- 496,500 ----
   * timeout value exceeded.
   */
! int GetKey(void)
  {
      int    ch, status, cc;
***************
*** 568,571 ****
   *           0 if a regular char with char stuffed in location c.
   */
  kbseq(getcfunc, recorder, bail_handler, c)
      int  (*getcfunc)();
--- 672,676 ----
   *           0 if a regular char with char stuffed in location c.
   */
+ int
  kbseq(getcfunc, recorder, bail_handler, c)
      int  (*getcfunc)();
***************
*** 739,742 ****
      int state;
  {
      extern char *_setbold, *_clearallattr;
  
--- 844,848 ----
      int state;
  {
+ #ifndef __riscos
      extern char *_setbold, *_clearallattr;
  
***************
*** 760,763 ****
  	}
      }
  }
  
--- 866,870 ----
  	}
      }
+ #endif
  }
  
***************
*** 772,775 ****
      int state;
  {
      extern char *_setinverse, *_clearinverse;
  
--- 879,883 ----
      int state;
  {
+ #ifndef __riscos
      extern char *_setinverse, *_clearinverse;
  
***************
*** 797,800 ****
  	}
      }
  }
  
--- 905,909 ----
  	}
      }
+ #endif
  }
  
***************
*** 809,812 ****
      int state;
  {
      extern char *_setunderline, *_clearunderline;
  
--- 918,922 ----
      int state;
  {
+ #ifndef __riscos
      extern char *_setunderline, *_clearunderline;
  
***************
*** 834,837 ****
  	}
      }
  }
  
--- 944,948 ----
  	}
      }
+ #endif
  }
  
***************
*** 836,841 ****
  StartInverse()
  {
      invstate = TRUE;
      reset_attr_state();
  }
  
--- 947,956 ----
  StartInverse()
  {
+ #ifdef __riscos
+     tinforev(1);
+ #else
      invstate = TRUE;
      reset_attr_state();
+ #endif
  }
  
***************
*** 847,855 ****
  EndInverse()
  {
      invstate = FALSE;
      reset_attr_state();
  }
  
  
  int
  InverseState()
--- 962,975 ----
  EndInverse()
  {
+ #ifdef __riscos
+     tinforev(0);
+ #else
      invstate = FALSE;
      reset_attr_state();
+ #endif
  }
  
  
+ #ifndef __riscos
  int
  InverseState()
***************
*** 885,888 ****
      reset_attr_state();
  }
  
  void
--- 1005,1009 ----
      reset_attr_state();
  }
+ #endif
  
  void
***************
*** 956,959 ****
  
  	if(ANSI_COLOR())
  	  putpad("\033[39;49m");
  	else{
--- 1077,1090 ----
  
  	if(ANSI_COLOR())
+ #ifdef __riscos
+ 	{
+           if (gmode&MDUSEANSI)
+ 	    _swix(OS_Write0,_IN(0),"\033[39;49m");
+ 	  else
+ 	  {
+ 	    /* Nothing to init */
+ 	  }
+ 	}
+ #else
  	  putpad("\033[39;49m");
  	else{
***************
*** 960,963 ****
  	      putpad(_oc);
  	}
      }
  }
--- 1091,1095 ----
  	      putpad(_oc);
  	}
+ #endif
      }
  }
***************
*** 998,1004 ****
  	else
  	  sprintf(buf, "\033[9%cm", (color-8) + '0');
! 	
  	putpad(buf);
      }
      else if(_setaf)
        putpad(tparm(_setaf, color));
--- 1130,1145 ----
  	else
  	  sprintf(buf, "\033[9%cm", (color-8) + '0');
! #ifdef __riscos
!         if (gmode&MDUSEANSI)
! 	  _swix(OS_Write0,_IN(0),buf);
! 	else
! 	{
! 	  /* Do nothing */
! 	}
! #else
  	putpad(buf);
+ #endif
      }
+ #ifndef __riscos
      else if(_setaf)
        putpad(tparm(_setaf, color));
***************
*** 1005,1008 ****
  	/* set color pair method */
      }
  
      return(0);
--- 1146,1150 ----
  	/* set color pair method */
      }
+ #endif
  
      return(0);
***************
*** 1036,1041 ****
  	  sprintf(buf, "\033[10%cm", (color-8) + '0');
  
  	putpad(buf);
      }
      else if(_setab)
        putpad(tparm(_setab, color));
--- 1178,1193 ----
  	  sprintf(buf, "\033[10%cm", (color-8) + '0');
  
+ #ifdef __riscos
+         if (gmode&MDUSEANSI)
+ 	  _swix(OS_Write0,_IN(0),buf);
+ 	else
+ 	{
+ 	  /* Do nothing */
+ 	}
+ #else
  	putpad(buf);
+ #endif
      }
+ #ifndef __riscos
      else if(_setab)
        putpad(tparm(_setab, color));
***************
*** 1042,1045 ****
  	/* set color pair method */
      }
  
      return(0);
--- 1194,1198 ----
  	/* set color pair method */
      }
+ #endif
  
      return(0);
***************
*** 1577,1581 ****
  	    free_color_table(&color_tbl);
  	    if(ANSI_COLOR())
  	      putpad("\033[39;49m");
  	    else{
  		if(_op)
--- 1730,1746 ----
  	    free_color_table(&color_tbl);
  	    if(ANSI_COLOR())
+ 	    {
+ #ifdef __riscos
+               if (gmode&MDUSEANSI)
+ 	        _swix(OS_Write0,_IN(0),"\033[39;49m");
+ 	      else
+ 	      {
+ 	        /* Do nothing */
+ 	      }
+ #else
  	      putpad("\033[39;49m");
+ #endif
+ 	    }
+ #ifndef __riscos
  	    else{
  		if(_op)
***************
*** 1569,1572 ****
  		  putpad(_oc);
  	    }
  	}
      }
--- 1734,1738 ----
  		  putpad(_oc);
  	    }
+ #endif
  	}
      }
***************
*** 2008,2013 ****
   *              suggest environment's EDITOR value as default.
   */
! alt_editor(f, n)
  {
      char   eb[NLINE];				/* buf holding edit command */
      char   *fn;					/* tmp holder for file name */
--- 2174,2180 ----
   *              suggest environment's EDITOR value as default.
   */
! int alt_editor(f, n)
  {
+ #ifndef __riscos
      char   eb[NLINE];				/* buf holding edit command */
      char   *fn;					/* tmp holder for file name */
***************
*** 2067,2070 ****
  	    }
  
  	    if(getenv("EDITOR"))
  	      strcpy(eb, (char *)getenv("EDITOR"));
--- 2234,2242 ----
  	    }
  
+ #ifdef __riscos
+ 	    if(getenv("Pilot$Editor"))
+ 	      strcpy(eb, (char *)getenv("Pilot$Editor"));
+ 	    else
+ #endif
  	    if(getenv("EDITOR"))
  	      strcpy(eb, (char *)getenv("EDITOR"));
***************
*** 4601,4604 ****
      emlwrite(result, f ? "speller" : "editor");
      return(0);
  }
  
--- 4773,4779 ----
      emlwrite(result, f ? "speller" : "editor");
      return(0);
+ #else
+     return(-1);
+ #endif
  }
  
***************
*** 2367,2370 ****
  
      return(1);
  #endif
  }
--- 2542,2547 ----
  
      return(1);
+ #else
+     return(0);
  #endif
  }
***************
*** 2435,2439 ****
  do_hup_signal SIG_PROTO((int sig))
  {
      signal(SIGHUP,  SIG_IGN);			/* ignore further SIGHUP's */
      signal(SIGTERM, SIG_IGN);			/* ignore further SIGTERM's */
      if(Pmaster){
--- 2612,2618 ----
  do_hup_signal SIG_PROTO((int sig))
  {
+ #ifndef __riscos
      signal(SIGHUP,  SIG_IGN);			/* ignore further SIGHUP's */
+ #endif
      signal(SIGTERM, SIG_IGN);			/* ignore further SIGTERM's */
      if(Pmaster){
***************
*** 2408,2417 ****
  	if(anycb() == TRUE){			/* time to save */
  	    if(curbp->b_fname[0] == '\0'){	/* name it */
  		strcpy(curbp->b_fname, "pico.save");
  	    }
  	    else{
  		strcat(curbp->b_fname, ".save");
  	    }
! 	    unlink(curbp->b_fname);
  	    writeout(curbp->b_fname, TRUE);
  	}
--- 2587,2604 ----
  	if(anycb() == TRUE){			/* time to save */
  	    if(curbp->b_fname[0] == '\0'){	/* name it */
+ #ifdef __riscos
+ 		strcpy(curbp->b_fname, "pico/save");
+ #else
  		strcpy(curbp->b_fname, "pico.save");
+ #endif
  	    }
  	    else{
+ #ifdef __riscos
+ 		strcat(curbp->b_fname, "/save");
+ #else
  		strcat(curbp->b_fname, ".save");
+ #endif
  	    }
! 	    remove(curbp->b_fname);
  	    writeout(curbp->b_fname, TRUE);
  	}
***************
*** 2471,2475 ****
        0,    0,			/* ^P - ^W, ^X - ^_  */
        0x80, 0x17,		/* SP - ' ,  ( - /   */
        0xff, 0xc4,		/*  0 - 7 ,  8 - ?   */
        0x7f, 0xff,		/*  @ - G ,  H - O   */
        0xff, 0xe1,		/*  P - W ,  X - _   */
--- 2658,2666 ----
        0,    0,			/* ^P - ^W, ^X - ^_  */
        0x80, 0x17,		/* SP - ' ,  ( - /   */
+ #ifdef __riscos
+       0xff, 0xc0,		/*  0 - 7 ,  8 - ?   */
+ #else
        0xff, 0xc4,		/*  0 - 7 ,  8 - ?   */
+ #endif
        0x7f, 0xff,		/*  @ - G ,  H - O   */
        0xff, 0xe1,		/*  P - W ,  X - _   */
***************
*** 2446,2450 ****
   * fallowc - returns TRUE if c is allowable in filenames, FALSE otw
   */
! fallowc(c)
  char c;
  {
--- 2637,2641 ----
   * fallowc - returns TRUE if c is allowable in filenames, FALSE otw
   */
! int fallowc(c)
  char c;
  {
***************
*** 2498,2501 ****
   *          FALSE otherwise.  By side effect returns length of file in l
   */
  fexist(file, m, l)
  char  *file;
--- 2689,2693 ----
   *          FALSE otherwise.  By side effect returns length of file in l
   */
+ int
  fexist(file, m, l)
  char  *file;
***************
*** 2462,2465 ****
  off_t *l;			/* t means use lstat         */
  {
      struct stat	sbuf;
      extern int lstat();
--- 2654,2686 ----
  off_t *l;			/* t means use lstat         */
  {
+ #ifdef __riscos
+   int obj;
+   int len;
+   {
+     char *tail=file+strlen(file);
+     if (strlen(file)>3)
+     {
+       if (strcmp(&tail[-2],"..")==0)
+       {
+         l=0;
+         return FIODIR;
+       }
+     }
+   }
+   _swix(OS_File,_INR(0,1)|_OUT(0)|_OUT(4),17,file,&obj,&len);
+   if (l!=NULL) *l=len; /* the length */
+   switch (obj)
+   {
+     case 0:
+      return(FIOFNF);
+     case 1:
+      return(FIOSUC);
+     case 2:
+      return(FIODIR);
+     case 3:
+      return(FIODIR);
+   }
+   return(FIOERR);
+ #else
      struct stat	sbuf;
      extern int lstat();
***************
*** 2575,2578 ****
        return((can_access(file,EXECUTE_ACCESS)==0) ? FIOSUC : FIONEX);
      return(FIOERR);				/* bad m arg */
  }
  
--- 2796,2800 ----
        return((can_access(file,EXECUTE_ACCESS)==0) ? FIOSUC : FIONEX);
      return(FIOERR);				/* bad m arg */
+ #endif
  }
  
***************
*** 2541,2544 ****
   *         silent on errors (we'll let someone else notice the problem;)).
   */
  isdir(fn, l, d)
  char *fn;
--- 2763,2767 ----
   *         silent on errors (we'll let someone else notice the problem;)).
   */
+ int
  isdir(fn, l, d)
  char *fn;
***************
*** 2587,2590 ****
  time_t *d;
  {
      struct stat sbuf;
  
--- 2810,2834 ----
  time_t *d;
  {
+ #ifdef __riscos
+   int obj;
+   int len;
+   {
+     char *tail=fn+strlen(fn);
+     if (strlen(fn)>3)
+     {
+       if (strcmp(&tail[-2],"..")==0)
+       {
+         l=0;
+         return 1;
+       }
+     }
+   }
+   _swix(OS_File,_INR(0,1)|_OUT(0)|_OUT(4),17,fn,&obj,&len);
+   if (l!=NULL)
+     *l=len; /* the length */
+   if (d)
+     *d=0; /* NO time just yet!!! */
+   return obj>1;
+ #else
      struct stat sbuf;
  
***************
*** 2561,2564 ****
  
      return((sbuf.st_mode&S_IFMT) == S_IFDIR);
  }
  
--- 2805,2809 ----
  
      return((sbuf.st_mode&S_IFMT) == S_IFDIR);
+ #endif
  }
  
***************
*** 2618,2623 ****
      if(home == NULL){
  	char buf[NLINE];
  	strcpy(buf, "~");
  	fixpath(buf, NLINE);		/* let fixpath do the work! */
  	hlen = strlen(buf);
  	if((home = (char *)malloc((hlen + 1) * sizeof(char))) == NULL){
--- 2863,2872 ----
      if(home == NULL){
  	char buf[NLINE];
+ #ifdef __riscos
+ 	strcpy(buf, "@");
+ #else
  	strcpy(buf, "~");
  	fixpath(buf, NLINE);		/* let fixpath do the work! */
+ #endif
  	hlen = strlen(buf);
  	if((home = (char *)malloc((hlen + 1) * sizeof(char))) == NULL){
***************
*** 2599,2602 ****
   *            user's home directory tree.
   */
  homeless(f)
  char *f;
--- 2848,2852 ----
   *            user's home directory tree.
   */
+ int
  homeless(f)
  char *f;
***************
*** 2667,2671 ****
  int err;
  {
      return((err >= 0 && err < sys_nerr) ? (char *)sys_errlist[err] : NULL);
  }
  
--- 2917,2925 ----
  int err;
  {
+ #ifndef __riscos
      return((err >= 0 && err < sys_nerr) ? (char *)sys_errlist[err] : NULL);
+ #else
+     return strerror(err);
+ #endif
  }
  
***************
*** 2636,2640 ****
  {
      long           l;
-     size_t	   avail, alloced, incr = 1024;
      char          *names, *np, *p;
      struct stat    sbuf;
--- 2890,2893 ----
  {
      long           l;
      char          *names, *np, *p;
      struct stat    sbuf;
***************
*** 2701,2704 ****
      if(stat(dn, &sbuf) < 0){
  	switch(errno){
  	  case ENOENT :				/* File not found */
  	    if(e)
--- 2954,2958 ----
      if(stat(dn, &sbuf) < 0){
  	switch(errno){
+ #ifdef ENOTENT
  	  case ENOENT :				/* File not found */
  	    if(e)
***************
*** 2660,2663 ****
  
  	    break;
  #ifdef	ENAMETOOLONG
  	  case ENAMETOOLONG :			/* Name is too long */
--- 2914,2918 ----
  
  	    break;
+ #endif
  #ifdef	ENAMETOOLONG
  	  case ENAMETOOLONG :			/* Name is too long */
***************
*** 2676,2685 ****
      } 
      else{
! #define MAX(x,y)        ((x) > (y) ? (x) : (y))
! 	/*
! 	 * We'd like to use 512 * st_blocks as an initial estimate but
! 	 * some systems have a stat struct with no st_blocks in it.
! 	 */
! 	avail = alloced = MAX(sbuf.st_size, incr);
  	if((sbuf.st_mode&S_IFMT) != S_IFDIR){
  	    if(e)
--- 2931,2935 ----
      }
      else{
! 	l = sbuf.st_size;
  	if((sbuf.st_mode&S_IFMT) != S_IFDIR){
  	    if(e)
***************
*** 2736,2742 ****
  	    return(NULL);
  	}
      }
  
!     if((names=(char *)malloc(alloced * sizeof(char))) == NULL){
  	if(e)
  	  sprintf(e, "\007Can't malloc space for file names");
--- 2986,3014 ----
  	    return(NULL);
  	}
+ 
+ #ifdef __riscos
+         /* JRF: FIXME: I don't think we get this right at the moment - check this */
+         /* This is a patch around the problem */
+       l = 0;
+       if((dirp=opendir(dn)) == NULL) {
+         if(e)
+           sprintf(e, "\007Can't open \"%s\": %s", dn, errstr(errno));
+         return(NULL);
+       }
+       if(!pat || !*pat || !strncmp("..", pat, strlen(pat))) {
+         l+=3;
+       }
+       while((dp = readdir(dirp)) != NULL)
+         if(!pat || !*pat || !strncmp(dp->d_name, pat, strlen(pat))) {
+           p = dp->d_name;
+           while(*p++)
+             l++;
+           l++;
+         }
+       closedir(dirp);					/* shut down */
+ #endif
      }
  
!     if((names=(char *)malloc(sizeof(char)*l)) == NULL){
  	if(e)
  	  sprintf(e, "\007Can't malloc space for file names");
***************
*** 2721,2748 ****
      }
  #else
      while((dp = readdir(dirp)) != NULL)
        if(!pat || !*pat || !strncmp(dp->d_name, pat, strlen(pat))){
  	  (*n)++;
  	  p = dp->d_name;
- 	  l = strlen(p);
- 	  while(avail < l+1){
- 	      char *oldnames;
- 
- 	      alloced += incr;
- 	      avail += incr;
- 	      oldnames = names;
- 	      if((names=(char *)realloc((void *)names, alloced * sizeof(char)))
- 		  == NULL){
- 		if(e)
- 		  sprintf(e, "\007Can't malloc enough space for file names");
- 
- 		return(NULL);
- 	      }
- 
- 	      np = names + (np-oldnames);
- 	  }
- 
- 	  avail -= (l+1);
- 
  	  while(*np++ = *p++)
  	    ;
--- 2993,3007 ----
      }
  #else
+ #ifdef __riscos
+     { /* 'parent' directory' */
+       p="..";
+       while(*np++ = *p++)
+         ;
+     }
+ #endif
      while((dp = readdir(dirp)) != NULL)
        if(!pat || !*pat || !strncmp(dp->d_name, pat, strlen(pat))){
  	  (*n)++;
  	  p = dp->d_name;
  	  while(*np++ = *p++)
  	    ;
***************
*** 2856,2859 ****
      char name[20];
  
      if(*fn == '~') {
          for(x = fn+1, y = name;
--- 3115,3119 ----
      char name[20];
  
+ #ifndef __riscos
      if(*fn == '~') {
          for(x = fn+1, y = name;
***************
*** 2838,2841 ****
  	  ;
      }
      return(fn);
  }
--- 3098,3102 ----
  	  ;
      }
+ #endif
      return(fn);
  }
***************
*** 2899,2902 ****
      size_t len;
  {
      register char *shft;
  
--- 3160,3164 ----
      size_t len;
  {
+ #ifndef __riscos
      register char *shft;
  
***************
*** 2880,2883 ****
  	pfnexpand(name, len);
      }
  }
  
--- 3142,3146 ----
  	pfnexpand(name, len);
      }
+ #endif
  }
  
***************
*** 2940,2947 ****
   *                         new path, by side effect, if things went OK
   */
  compresspath(base, path, len)
  char *base, *path;
  int  len;
  {
      register int i;
      int  depth = 0;
--- 3203,3212 ----
   *                         new path, by side effect, if things went OK
   */
+ int
  compresspath(base, path, len)
  char *base, *path;
  int  len;
  {
+ #ifndef __riscos
      register int i;
      int  depth = 0;
***************
*** 2949,2952 ****
  	strcat(path, stack[i]);
      }
  
      return(1);					/* everything's ok */
--- 3214,3218 ----
  	strcat(path, stack[i]);
      }
+ #endif
  
      return(1);					/* everything's ok */
***************
*** 3003,3006 ****
  
  
  /*
   *     Check if we can access a file in a given way
--- 3269,3273 ----
  
  
+ #ifndef __riscos
  /*
   *     Check if we can access a file in a given way
***************
*** 3082,3085 ****
      /*NOTREACHED*/
  }
  
  
--- 3349,3353 ----
      /*NOTREACHED*/
  }
+ #endif
  
  
***************
*** 3159,3162 ****
          return((char *)NULL);
  
      if(!dir && (f = getenv("TMPDIR")) && !stat(f, &buf) &&
                           (buf.st_mode&S_IFMT) == S_IFDIR &&
--- 3427,3431 ----
          return((char *)NULL);
  
+ #ifndef __riscos
      if(!dir && (f = getenv("TMPDIR")) && !stat(f, &buf) &&
                           (buf.st_mode&S_IFMT) == S_IFDIR &&
***************
*** 3185,3188 ****
  
      return(was_nonexistent_tmp_name(name, 1));
  }
  
--- 3454,3467 ----
  
      return(was_nonexistent_tmp_name(name, 1));
+ #else
+   {
+     static int cnt=0;
+     if (dir==NULL)
+       sprintf(name, "<Wimp$ScrapDir>.%s%i-%d", prefix, cnt++, getpid());
+     else
+       sprintf(name, "%s.%s%i-%d", dir, prefix, cnt++, getpid());
+   }
+   return name;
+ #endif
  }
  
***************
*** 3357,3361 ****
      char *t;
  
      if(t = temp_nam((dir && *dir) ? dir : NULL, "pico.")){
  	strncpy(name, t, NFILEN-1);
  	name[NFILEN-1] = '\0';
--- 3636,3644 ----
      char *t;
  
+ #ifndef __riscos
      if(t = temp_nam((dir && *dir) ? dir : NULL, "pico.")){
+ #else
+     if(t = temp_nam((dir && *dir) ? dir : NULL, "pico")){
+ #endif
  	strncpy(name, t, NFILEN-1);
  	name[NFILEN-1] = '\0';
***************
*** 3231,3236 ****
        ++cp1;
  
      while (cp1!=&fname[0] && cp1[-1]!='/')
        --cp1;
  
      cp2 = &bname[0];
--- 3514,3524 ----
        ++cp1;
  
+ #ifdef __riscos
      while (cp1!=&fname[0] && cp1[-1]!='/')
        --cp1;
+ #else
+     while (cp1!=&fname[0] && cp1[-1]!='.')
+       --cp1;
+ #endif
  
      cp2 = &bname[0];
***************
*** 3406,3409 ****
  char *a, *b;
  {
      int    in, out, n, rv = 0;
      char   *cb;
--- 3694,3698 ----
  char *a, *b;
  {
+ #ifndef __riscos
      int    in, out, n, rv = 0;
      char   *cb;
***************
*** 3334,3337 ****
      close(out);
      return(rv);
  }
  
--- 3623,3641 ----
      close(out);
      return(rv);
+ #else
+   int regs[11];
+   _kernel_oserror *err;
+   regs[0]=26; /* copy objects */
+   regs[1]=(int)a;  /* source */
+   regs[2]=(int)b;  /* destination */
+   regs[3]=1+2+(1<<9); /* Recurse, Force, Access as source */
+   err=_swix(OS_FSControl,_INR(0,3),26,a,b,1+2+(1<<9));
+ 
+     if (err!=NULL){		/* get source file info */
+ 	emlwrite("Can't copy: %s", err->errmess);
+ 	return(-1);
+     }
+     return(0);
+ #endif
  }
  
***************
*** 3498,3507 ****
   * (cannot create).
   */
  ffwopen(fn, readonly)
  char    *fn;
  int	 readonly;
  {
-     int		 fd;
      extern FIOINFO g_pico_fio;
  #ifndef	MODE_READONLY
  #define	MODE_READONLY	(0600)
--- 3802,3824 ----
   * (cannot create).
   */
+ int
  ffwopen(fn, readonly)
  char    *fn;
  int	 readonly;
  {
      extern FIOINFO g_pico_fio;
+ #ifdef __riscos
+     FILE *ffp;
+ 
+ /* JRF: Note: We ignore the readonly bit */
+     if ((ffp=fopen(fn, "w")) == NULL) {
+         emlwrite("Cannot open file for writing", NULL);
+         return (FIOERR);
+     }
+     g_pico_fio.fp=ffp;
+ 
+     return (FIOSUC);
+ #else
+     int		 fd;
  #ifndef	MODE_READONLY
  #define	MODE_READONLY	(0600)
***************
*** 3367,3370 ****
      emlwrite("Cannot open file for writing: %s", errstr(errno));
      return (FIOERR);
  }
  
--- 3684,3688 ----
      emlwrite("Cannot open file for writing: %s", errstr(errno));
      return (FIOERR);
+ #endif
  }
  
***************
*** 3530,3536 ****
   * Close a file. Should look at the status in all systems.
   */
! ffclose()
  {
      extern FIOINFO g_pico_fio;
  
      errno = 0;
--- 3848,3863 ----
   * Close a file. Should look at the status in all systems.
   */
! int
! ffclose(void)
  {
      extern FIOINFO g_pico_fio;
+ #ifdef __riscos
+     if (fclose(g_pico_fio.fp) != FALSE) {
+         emlwrite("Error closing file", NULL);
+         return(FIOERR);
+     }
+ 
+     return(FIOSUC);
+ #else
  
      errno = 0;
***************
*** 3392,3395 ****
  
      return(FIOSUC);
  }
  
--- 3719,3723 ----
  
      return(FIOSUC);
+ #endif
  }
  
***************
*** 3560,3565 ****
   *		 what we're about to write...
   */
  ffelbowroom()
  {
      register LINE *lp;
      register long  n;
--- 3888,3895 ----
   *		 what we're about to write...
   */
+ int
  ffelbowroom()
  {
+ #ifndef __riscos
      register LINE *lp;
      register long  n;
***************
*** 3456,3459 ****
  	return(FALSE);
      }
  
      return(TRUE);
--- 3786,3792 ----
  	return(FALSE);
      }
+ #else
+     /* No implementation room for RISC OS */
+ #endif
  
      return(TRUE);
***************
*** 3630,3634 ****
  char *s;
  {
      return(popen(s, "r"));
  }
  
--- 3963,3972 ----
  char *s;
  {
+ #ifndef __riscos
      return(popen(s, "r"));
+ #else
+     printf("P_open not implemented\n");
+     return NULL;
+ #endif
  }
  
***************
*** 3486,3490 ****
  FILE *fp;
  {
      pclose(fp);
  }
  
--- 3824,3832 ----
  FILE *fp;
  {
+ #ifndef __riscos
      pclose(fp);
+ #else
+     printf("P_close not implemented\n");
+ #endif
  }
  
***************
*** 3649,3653 ****
  
  /*
!  * worthit - generic sort of test to roughly gage usefulness of using 
   *           optimized scrolling.
   *
--- 3991,3995 ----
  
  /*
!  * worthit - generic sort of test to roughly guage usefulness of using
   *           optimized scrolling.
   *
***************
*** 3498,3501 ****
   *	returns the line on the screen, l, that the dot is currently on
   */
  worthit(l)
  int *l;
--- 3840,3844 ----
   *	returns the line on the screen, l, that the dot is currently on
   */
+ int
  worthit(l)
  int *l;
***************
*** 3673,3677 ****
   *	           if it's possible that they have new mail.
   */
! pico_new_mail()
  {
      int ret = 0;
--- 4016,4021 ----
   *	           if it's possible that they have new mail.
   */
! int
! pico_new_mail(void)
  {
      int ret = 0;
***************
*** 3523,3526 ****
      char   inbox[256], *p;
  
      if(p = (char *)getenv("MAIL"))
        sprintf(inbox, p);
--- 3867,3871 ----
      char   inbox[256], *p;
  
+ #ifndef __riscos
      if(p = (char *)getenv("MAIL"))
        sprintf(inbox, p);
***************
*** 3691,3697 ****
  	  (lastchk < sbuf.st_mtime && lastchk < sbuf.st_atime);
  	lastchk = sbuf.st_mtime;
- 	return(ret);
      }
!     else
        return(ret);
  }
--- 4036,4041 ----
  	  (lastchk < sbuf.st_mtime && lastchk < sbuf.st_atime);
  	lastchk = sbuf.st_mtime;
      }
! #endif
      return(ret);
  }
***************
*** 3546,3550 ****
   *                 and returns true if the elapsed time is > timeo
   */
! time_to_check()
  {
      static time_t lasttime = 0L;
--- 3890,3895 ----
   *                 and returns true if the elapsed time is > timeo
   */
! int
! time_to_check(void)
  {
      static time_t lasttime = 0L;
***************
*** 3828,3831 ****
      int   n;
  {
      unsigned pid;
      char    *chp;
--- 4173,4177 ----
      int   n;
  {
+ #ifdef __riscos
      unsigned pid;
      char    *chp;
***************
*** 3700,3705 ****
  	pid /= 10;
      }
  
!     unlink(file);
  }
  
--- 4046,4083 ----
  	pid /= 10;
      }
+ #else
+     unsigned pid;
+     char    *chp;
  
!     if(!file[0]){
! 	long gmode_save = gmode;
! 
! 	if(gmode&MDCURDIR)
! 	  gmode &= ~MDCURDIR;  /* so fixpath will use home dir */
! 
! 	strcpy(file, "picoXXXXX");
! 	fixpath(file, NLINE);
! 	gmode = gmode_save;
!     }
!     else{
! 	int l = strlen(file);
! 
! /* Gerph's change to work with arc dirs (Plus #'s removed from names)*/
! 	if(file[l-1] != '.'){
! 	    file[l++] = '.';
! 	    file[l]   = '\0';
! 	}
! 
! 	strcpy(file + l, "picoXXXXX");
!     }
! 
!     pid = (unsigned)getpid();
!     for(chp = file+strlen(file) - 2; *chp == 'X'; chp--){
! 	*chp = (pid % 10) + '0';
! 	pid /= 10;
!     }
! #endif
! 
!     remove(file);
  }
  
***************
*** 4273,4276 ****
   *           correction
   */
  spell(f, n)
      int f, n;
--- 4651,4655 ----
   *           correction
   */
+ int
  spell(f, n)
      int f, n;
***************
*** 4293,4305 ****
      }
  
      if((sp = (char *)getenv("SPELL")) == NULL)
        sp = SPELLER;
  
      sprintf(cb, "( %s ) < %s", sp, fn);		/* pre-use buffer! */
      if((p = P_open(cb)) == NULL){ 		/* read output from command */
! 	unlink(fn);
  	emlwrite("Can't fork spell checker", NULL);
  	return(-1);
      }
  
      ret = 1;
--- 4672,4708 ----
      }
  
+ #ifdef __riscos
+     if((sp = (char *)getenv("Pico$Spell")) == NULL)
+ #endif
      if((sp = (char *)getenv("SPELL")) == NULL)
        sp = SPELLER;
  
+ #ifdef __riscos
+   {
+     char tempfile[NLINE];
+     tmpname(NULL,tempfile);
+ 
+     sprintf(cb, "%s < %s > %s", sp, fn, tempfile);	/* pre-use buffer! */
+     if (system(cb)<0)
+     {
+ 	remove(fn);
+ 	emlwrite("Can't launch spell checker", NULL);
+ 	return(-1);
+     }
+ 
+     if((p = fopen(tempfile,"r")) == NULL){ 		/* read output from command */
+ 	remove(fn);
+ 	remove(tempfile);
+ 	emlwrite("Can't read spell checker output", NULL);
+ 	return(-1);
+     }
+ #else
      sprintf(cb, "( %s ) < %s", sp, fn);		/* pre-use buffer! */
      if((p = P_open(cb)) == NULL){ 		/* read output from command */
! 	remove(fn);
  	emlwrite("Can't fork spell checker", NULL);
  	return(-1);
      }
+ #endif
  
      ret = 1;
***************
*** 4222,4227 ****
  	}
      }
      P_close(p);					/* clean up */
!     unlink(fn);
      swapimark(0, 1);
      curwp->w_flag |= WFHARD|WFMODE;
--- 4625,4638 ----
  	}
      }
+ #ifdef __riscos
+     fclose(p);					/* clean up */
+ #else
      P_close(p);					/* clean up */
! #endif
!     remove(fn);
! #ifdef __riscos
!     remove(tempfile);
!   }
! #endif
      swapimark(0, 1);
      curwp->w_flag |= WFHARD|WFMODE;
***************
*** 4398,4401 ****
   *		FALSE otherwise
   */
  movetoword(w)
    char *w;
--- 4809,4813 ----
   *		FALSE otherwise
   */
+ int
  movetoword(w)
    char *w;
***************
*** 5200,5204 ****
  #endif	/* SPELLER */
  
! 
  
  /*
--- 5612,5616 ----
  #endif	/* SPELLER */
  
! int cached_read=-1;
  
  /*
***************
*** 4324,4327 ****
       int time_out;
  {
       struct timeval tmo;
       fd_set         readfds, errfds;
--- 4736,4769 ----
       int time_out;
  {
+ #ifdef __riscos
+      int start=0;
+ 
+      if (cached_read != -1)
+        return READY_TO_READ;
+ 
+      start=clock();
+ 
+      do
+      {
+        int type;
+        _swix(OS_UpCall,_INR(0,1),6,0);
+        if (_swix(OS_Byte,_INR(0,2)|_OUTR(1,2),129,0,0,&cached_read,&type))
+          return PANIC_NOW;
+        if (type==0)
+          return(READY_TO_READ);
+        if (type==27)
+        {
+          cached_read=27;
+          return READ_INTR;;
+        }
+        cached_read=-1;
+      }
+      while ((clock()-start) < time_out*CLOCKS_PER_SEC);
+ 
+      if (time_out>15)
+        return NO_OP_COMMAND;
+      else
+        return NO_OP_IDLE;
+ #else
       struct timeval tmo;
       fd_set         readfds, errfds;
***************
*** 4438,4441 ****
           }
       }
  
       return(READY_TO_READ);
--- 4880,4884 ----
           }
       }
+ #endif
  
       return(READY_TO_READ);
***************
*** 4447,4450 ****
  read_one_char()
  {
       int	    res;
       unsigned char  c;
--- 4890,4937 ----
  read_one_char()
  {
+ #ifdef __riscos
+       int	    res;
+       int            c;
+       _kernel_oserror *err;
+ 
+       if (cached_read!=-1)
+       {
+         c=cached_read;
+         cached_read=-1;
+       }
+       else
+       {
+ 
+         err=_swix(OS_ReadC,_OUT(0),&c);
+ 
+         if (err)
+           return BAIL_OUT;
+       }
+ 
+       switch (c)
+       {
+         case 0x81: c=F1;                 break;
+         case 0x82: c=F2;                 break;
+         case 0x83: c=F3;                 break;
+         case 0x84: c=F4;                 break;
+         case 0x85: c=F5;                 break;
+         case 0x86: c=F6;                 break;
+         case 0x87: c=F7;                 break;
+         case 0x88: c=F8;                 break;
+         case 0x89: c=F9;                 break;
+         case 0xCA: c=F10;                break;
+         case 0xCB: c=F11;                break;
+         case 0xCC: c=F12;                break;
+         case 0x8b: c=KEY_END;            break;
+         case 0x8c: c=KEY_LEFT;           break;
+         case 0x8d: c=KEY_RIGHT;          break;
+         case 0x8e: c=KEY_DOWN;           break;
+         case 0x8f: c=KEY_UP;             break;
+         case 0x9e: c=KEY_PGDN;           break;
+         case 0x9f: c=KEY_PGUP;           break;
+         case 30:   c=KEY_HOME;           break;
+         case 8:    c=0x7f;               break;
+       }
+ #else
       int	    res;
       unsigned char  c;
***************
*** 4469,4472 ****
  	   return(BAIL_OUT);
       }
  
       return((int)c);
--- 4956,4960 ----
  	   return(BAIL_OUT);
       }
+ #endif
  
       return((int)c);
***************
*** 4436,4440 ****
  
  
! 
  /*
   * TTY setup routines. These are the TERMIOS-style (POSIX) routines.
--- 4924,4928 ----
  
  
! #ifndef __riscos
  /*
   * TTY setup routines. These are the TERMIOS-style (POSIX) routines.
***************
*** 4590,4594 ****
      }
  }
! 
  
  /*
--- 5078,5082 ----
      }
  }
! #endif
  
  /*
***************
*** 4637,4641 ****
  flush_input()
  {
      tcflush(STDIN_FD, TCIFLUSH);
  }
  
--- 5125,5131 ----
  flush_input()
  {
+ #ifndef __riscos
      tcflush(STDIN_FD, TCIFLUSH);
+ #endif
  }
  
***************
*** 4612,4617 ****
  bit_strip_off()
  {
      _raw_tty.c_iflag &= ~ISTRIP;
      tcsetattr(STDIN_FD, TCSADRAIN, &_raw_tty);
  }
  
--- 5102,5109 ----
  bit_strip_off()
  {
+ #ifndef __riscos
      _raw_tty.c_iflag &= ~ISTRIP;
      tcsetattr(STDIN_FD, TCSADRAIN, &_raw_tty);
+ #endif
  }
  
***************
*** 4667,4671 ****
  ttisslow()
  {
      return(cfgetospeed(&_raw_tty) < B4800);
  }
  
--- 5159,5168 ----
  ttisslow()
  {
+ #ifndef __riscos
      return(cfgetospeed(&_raw_tty) < B4800);
+ #else
+   /* Hell, we're running it locally - it shouldn't be slow ! */
+   return (taskwindow());
+ #endif
  }
  
***************
*** 4676,4680 ****
  
  static int      tinfomove PROTO((int, int));
! static int      tinfoeeol PROTO((void));
  static int      tinfoeeop PROTO((void));
  static int      tinfobeep PROTO((void));
--- 5173,5177 ----
  
  static int      tinfomove PROTO((int, int));
! static int      tinfoeeol PROTO((int));
  static int      tinfoeeop PROTO((void));
  static int      tinfobeep PROTO((void));
***************
*** 4850,4853 ****
  
      /*
       * ANSI mode.
       */
--- 5347,5358 ----
  
      /*
+      * VT220 keypad function
+      */
+     kpinsert("\033[5~", KEY_PGUP, 1);
+     kpinsert("\033[6~", KEY_PGDN, 1);
+     kpinsert("\033[1~", KEY_HOME, 1);
+     kpinsert("\033[4~", KEY_END, 1);
+ 
+     /*
       * ANSI mode.
       */
***************
*** 4845,4848 ****
      int termcap_wins;
  {
      char   *_ku, *_kd, *_kl, *_kr,
  	   *_kppu, *_kppd, *_kphome, *_kpend, *_kpdel,
--- 5350,5354 ----
      int termcap_wins;
  {
+ #ifndef __riscos
      char   *_ku, *_kd, *_kl, *_kr,
  	   *_kppu, *_kppd, *_kphome, *_kpend, *_kpdel,
***************
*** 5070,5073 ****
      kpinsert(_kf12, F12, termcap_wins);
  
      /*
       * Add default keypad sequences to the trie.
--- 5576,5625 ----
      kpinsert(_kf12, F12, termcap_wins);
  
+ #else
+     int     row, col;
+     char   *er;
+     char   *ec;
+     int     cc,rr;
+ 
+     int sregs[11];
+ 
+     /*
+      * determine the terminal's communication speed and decide
+      * if we need to do optimization ...
+      */
+     optimize = 0;/*ttisslow();*/
+ 
+     if (taskwindow())
+     {
+       row=-1; col=-1;
+       revexist=FALSE;
+     }
+     else
+     {
+       int vars[]={ 256, 257, -1 };
+       if (_swix(OS_ReadVduVariables,_INR(0,1),&vars[0],&vars[0]))
+       {
+         printf("Failed to read window size\n");
+       }
+       col=vars[0];
+       row=vars[1];
+ 
+       revexist=TRUE;
+     }
+     /* Now check if there is an override on these */
+     er = getenv("Pico$Lines");
+     if (er==NULL && taskwindow()) er = getenv("Lines");
+     if(!er && (rr = atoi(er)) > 0)
+       row = rr-1;
+     ec = getenv("Pico$Columns");
+     if (ec==NULL && taskwindow()) ec = getenv("Columns");
+     if (!ec && (cc = atoi(ec)) > 0)
+       col = cc;
+ 
+     ttgetwinsz(&row, &col);
+     term.t_nrow = (short) row;
+     term.t_ncol = (short) col;
+ 
+ #endif
      /*
       * Add default keypad sequences to the trie.
***************
*** 5010,5014 ****
       * correct if you define TERMCAP_WINS.
       */
!     if(termcap_wins)
        setup_dflt_esc_seq();
  
--- 5562,5566 ----
       * correct if you define TERMCAP_WINS.
       */
!     /* if(termcap_wins) */
      setup_dflt_esc_seq();
  
***************
*** 5091,5094 ****
  tinfoopen()
  {
      int     row, col;
  
--- 5643,5647 ----
  tinfoopen()
  {
+ #ifndef __riscos
      int     row, col;
  
***************
*** 5055,5061 ****
  	}
      }
  
      ttopen();
  
      if(_termcap_init && !Pmaster) {
  	putpad(_termcap_init);		/* any init terminfo requires */
--- 5608,5623 ----
  	}
      }
+ #else
+     /* eolexist = !taskwindow();	/-* able to use clear to EOL? -*/
+     eolexist = TRUE;
+     revexist = TRUE;            /* Pretend we can do reverse */
+     scrollexist = FALSE;        /* No scroll operations */
+     inschar = FALSE;            /* No insert character */
+     delchar = FALSE;            /* No insert character */
+ #endif
  
      ttopen();
  
+ #ifndef __riscos
      if(_termcap_init && !Pmaster) {
  	putpad(_termcap_init);		/* any init terminfo requires */
***************
*** 5132,5140 ****
  	  putpad(tgoto(_scrollregion, term.t_nrow, 0)) ;
      }
  
      /*
       * Initialize UW-modified NCSA telnet to use its functionkeys
       */
!     if(gmode&MDFKEY && Pmaster == NULL)
        puts("\033[99h");
  
--- 5694,5703 ----
  	  putpad(tgoto(_scrollregion, term.t_nrow, 0)) ;
      }
+ #endif
  
      /*
       * Initialize UW-modified NCSA telnet to use its functionkeys
       */
!     if(gmode&MDFKEY && Pmaster == NULL && gmode&MDUSEANSI)
        puts("\033[99h");
  
***************
*** 5078,5086 ****
  {
      if(!Pmaster){
! 	if(gmode&MDFKEY)
  	  puts("\033[99l");		/* reset UW-NCSA telnet keys */
  
  	if(_termcap_end)		/* any clean up terminfo requires */
  	  putpad(_termcap_end);
      }
  
--- 5641,5651 ----
  {
      if(!Pmaster){
! 	if(gmode&MDFKEY && gmode&MDUSEANSI)
  	  puts("\033[99l");		/* reset UW-NCSA telnet keys */
  
+ #ifndef __riscos
  	if(_termcap_end)		/* any clean up terminfo requires */
  	  putpad(_termcap_end);
+ #endif
      }
  
***************
*** 5169,5172 ****
  register int	ch;
  {
      if(_insertchar != NULL){
  	putpad(_insertchar);
--- 5734,5738 ----
  register int	ch;
  {
+ #ifndef __riscos
      if(_insertchar != NULL){
  	putpad(_insertchar);
***************
*** 5109,5112 ****
  	putpad(_endinsert);
      }
  }
  
--- 5675,5681 ----
  	putpad(_endinsert);
      }
+ #else
+     _swix(OS_Write0,_IN(0),"tinfoinsert not supported");
+ #endif
  }
  
***************
*** 5187,5190 ****
  tinfodelete()
  {
      if(_startdelete == NULL && _enddelete == NULL)
        putpad(_deletechar);
--- 5756,5760 ----
  tinfodelete()
  {
+ #ifndef __riscos
      if(_startdelete == NULL && _enddelete == NULL)
        putpad(_deletechar);
***************
*** 5125,5128 ****
  	putpad(_enddelete);
      }
  }
  
--- 5695,5701 ----
  	putpad(_enddelete);
      }
+ #else
+     _swix(OS_Write0,_IN(0),"tinfodelete not supported");
+ #endif
  }
  
***************
*** 5202,5209 ****
   *               to open a new line.
   */
  o_scrolldown(row, n)
  register int row;
  register int n;
  {
      register int i;
  
--- 5775,5786 ----
   *               to open a new line.
   */
+ int
  o_scrolldown(row, n)
  register int row;
  register int n;
  {
+ #ifdef __riscos
+   _swix(OS_Write0,_IN(0),"o_scrolldown should not get called\n");
+ #else
      register int i;
  
***************
*** 5169,5172 ****
  #endif
      }
  
      /* return ignored */
--- 5746,5750 ----
  #endif
      }
+ #endif
  
      /* return ignored */
***************
*** 5249,5256 ****
   *               to open a new line.
   */
  o_scrollup(row, n)
  register int row;
  register int n;
  {
      register int i;
  
--- 5827,5838 ----
   *               to open a new line.
   */
+ int
  o_scrollup(row, n)
  register int row;
  register int n;
  {
+ #ifdef __riscos
+   _swix(OS_Write0,_IN(0),"o_scrollup should not get called\n");
+ #else
      register int i;
  
***************
*** 5169,5173 ****
  #endif
      }
! 
      /* return ignored */
      return(0);
--- 5751,5755 ----
  #endif
      }
! #endif
      /* return ignored */
      return(0);
***************
*** 5337,5347 ****
   *            returns: true if it optimized output, false otherwise
   */
  o_insert(c)
  int c;
  {
      if(inschar){
  	tinfoinsert(c);
  	return(1);			/* no problems! */
      }
  
      return(0);				/* can't do it. */
--- 5919,5932 ----
   *            returns: true if it optimized output, false otherwise
   */
+ int
  o_insert(c)
  int c;
  {
+ #ifndef __riscos
      if(inschar){
  	tinfoinsert(c);
  	return(1);			/* no problems! */
      }
+ #endif
  
      return(0);				/* can't do it. */
***************
*** 5196,5205 ****
   *            returns true if it optimized output, false otherwise
   */
  o_delete()
  {
      if(delchar){
  	tinfodelete();
  	return(1);			/* deleted, no problem! */
      }
  
      return(0);				/* no dice. */
--- 5781,5793 ----
   *            returns true if it optimized output, false otherwise
   */
+ int
  o_delete()
  {
+ #ifndef __riscos
      if(delchar){
  	tinfodelete();
  	return(1);			/* deleted, no problem! */
      }
+ #endif
  
      return(0);				/* no dice. */
***************
*** 5364,5372 ****
  
  
  static tinfomove(row, col)
  register int row, col;
  {
      putpad(tgoto(_moveto, col, row));
! 
      /* return ignored */
      return(0);
--- 5952,5990 ----
  
  
+ void
+ ansiparm(n)
+ register int    n;
+ {
+         register int    q;
+ 
+         q = n/10;
+         if (q != 0)
+                 ansiparm(q);
+         _swix(OS_WriteC,_IN(0),((n%10) + '0'));
+ }
+ 
+ 
  static tinfomove(row, col)
  register int row, col;
  {
+ #ifdef __riscos
+   if (gmode & MDUSEANSI)
+   {
+     _swix(OS_WriteC,_IN(0),27);
+     _swix(OS_WriteC,_IN(0),'[');
+     ansiparm(row+1);
+     _swix(OS_WriteC,_IN(0),';');
+     ansiparm(col+1);
+     _swix(OS_WriteC,_IN(0),'H');
+   }
+   else
+   {
+     _swix(OS_WriteC,_IN(0),31);
+     _swix(OS_WriteC,_IN(0),col);
+     _swix(OS_WriteC,_IN(0),row);
+   }
+ #else
      putpad(tgoto(_moveto, col, row));
! #endif
      /* return ignored */
      return(0);
***************
*** 5217,5222 ****
  
  
! static tinfoeeol()
  {
      int   c, starting_col, starting_line;
      char *last_bg_color;
--- 5835,5841 ----
  
  
! static int tinfoeeol(int fromx)
  {
+ #ifndef __riscos
      int   c, starting_col, starting_line;
      char *last_bg_color;
***************
*** 5401,5405 ****
      else if(_cleartoeoln)
        putpad(_cleartoeoln);
! 
      /* return ignored */
      return(0);
--- 6020,6062 ----
      else if(_cleartoeoln)
        putpad(_cleartoeoln);
! #else
!   if (gmode & MDUSEANSI)
!   {
!     _swix(OS_WriteC,_IN(0),27);
!     _swix(OS_WriteC,_IN(0),'[');
!     _swix(OS_WriteC,_IN(0),'K');
!   }
!   else
!   {
!     if (taskwindow())
!     {
!       /* TaskWindows (at least Zap ones) don't support the 'delete to end of
!          line' */
!       int i;
!       for (i=term.t_ncol; i>fromx; i--)
!       {
!         _swix(OS_WriteC,_IN(0),' ');
!       }
!       for (i=term.t_ncol; i>fromx; i--)
!       {
!         _swix(OS_WriteC,_IN(0),8);
!       }
!     }
!     else
!     {
!       _swix(OS_WriteC,_IN(0),23);
!       _swix(OS_WriteC,_IN(0),8);
!       _swix(OS_WriteC,_IN(0),5);
!       _swix(OS_WriteC,_IN(0),6);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!       _swix(OS_WriteC,_IN(0),0);
!     }
!   }
! #endif
      /* return ignored */
      return(0);
***************
*** 5252,5255 ****
  static tinfoeeop()
  {
      int i, starting_col, starting_row;
  
--- 5909,5913 ----
  static tinfoeeop()
  {
+ #ifndef __riscos
      int i, starting_col, starting_row;
  
***************
*** 5430,5433 ****
      else if(_cleartoeos)
        putpad(_cleartoeos);
  
      /* return ignored */
--- 6088,6103 ----
      else if(_cleartoeos)
        putpad(_cleartoeos);
+ #else
+   if (gmode & MDUSEANSI)
+   {
+     _swix(OS_WriteC,_IN(0),27);
+     _swix(OS_WriteC,_IN(0),'[');
+     _swix(OS_WriteC,_IN(0),'J');
+   }
+   else
+   {
+     _swix(OS_WriteC,_IN(0),12);
+   }
+ #endif
  
      /* return ignored */
***************
*** 5279,5289 ****
  
  
! static tinforev(state)		/* change reverse video status */
  int state;			/* FALSE = normal video, TRUE = rev video */
  {
      if(state)
        StartInverse();
      else
        EndInverse();
  
      return(1);
--- 5949,5989 ----
  
  
! static int tinforev(state)	/* change reverse video status */
  int state;			/* FALSE = normal video, TRUE = rev video */
  {
+ #ifdef __riscos
+   static int cstate = FALSE;
+ 
+   if(state == cstate)		/* no op if already set! */
+     return(0);
+ 
+   cstate = state;
+   if (gmode & MDUSEANSI)
+   {
+     _swix(OS_WriteC,_IN(0),27);
+     _swix(OS_WriteC,_IN(0),'[');
+     _swix(OS_WriteC,_IN(0),(state ? '7': '0'));
+     _swix(OS_WriteC,_IN(0),'m');
+   }
+   else
+   {
+     _swix(OS_WriteC,_IN(0),23);
+     _swix(OS_WriteC,_IN(0),17);
+     _swix(OS_WriteC,_IN(0),5);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+     _swix(OS_WriteC,_IN(0),0);
+   }
+ #else
      if(state)
        StartInverse();
      else
        EndInverse();
+ #endif
  
      return(1);
